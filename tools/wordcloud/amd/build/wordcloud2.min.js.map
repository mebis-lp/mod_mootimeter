{"version":3,"file":"wordcloud2.min.js","sources":["../src/wordcloud2.js"],"sourcesContent":["/*!\n * wordcloud2.js\n * http://timdream.org/wordcloud2.js/\n *\n * Copyright 2011 - 2019 Tim Guan-tin Chien and contributors.\n * Released under the MIT license\n */\n\n'use strict'\n\n// setImmediate\nif (!window.setImmediate) {\n  window.setImmediate = (function setupSetImmediate () {\n    return window.msSetImmediate ||\n    window.webkitSetImmediate ||\n    window.mozSetImmediate ||\n    window.oSetImmediate ||\n    (function setupSetZeroTimeout () {\n      if (!window.postMessage || !window.addEventListener) {\n        return null\n      }\n\n      var callbacks = [undefined]\n      var message = 'zero-timeout-message'\n\n      // Like setTimeout, but only takes a function argument.  There's\n      // no time argument (always zero) and no arguments (you have to\n      // use a closure).\n      var setZeroTimeout = function setZeroTimeout (callback) {\n        var id = callbacks.length\n        callbacks.push(callback)\n        window.postMessage(message + id.toString(36), '*')\n\n        return id\n      }\n\n      window.addEventListener('message', function setZeroTimeoutMessage (evt) {\n        // Skipping checking event source, retarded IE confused this window\n        // object with another in the presence of iframe\n        if (typeof evt.data !== 'string' ||\n            evt.data.substr(0, message.length) !== message/* ||\n            evt.source !== window */) {\n          return\n        }\n\n        evt.stopImmediatePropagation()\n\n        var id = parseInt(evt.data.substr(message.length), 36)\n        if (!callbacks[id]) {\n          return\n        }\n\n        callbacks[id]()\n        callbacks[id] = undefined\n      }, true)\n\n      /* specify clearImmediate() here since we need the scope */\n      window.clearImmediate = function clearZeroTimeout (id) {\n        if (!callbacks[id]) {\n          return\n        }\n\n        callbacks[id] = undefined\n      }\n\n      return setZeroTimeout\n    })() ||\n    // fallback\n    function setImmediateFallback (fn) {\n      window.setTimeout(fn, 0)\n    }\n  })()\n}\n\nif (!window.clearImmediate) {\n  window.clearImmediate = (function setupClearImmediate () {\n    return window.msClearImmediate ||\n    window.webkitClearImmediate ||\n    window.mozClearImmediate ||\n    window.oClearImmediate ||\n    // \"clearZeroTimeout\" is implement on the previous block ||\n    // fallback\n    function clearImmediateFallback (timer) {\n      window.clearTimeout(timer)\n    }\n  })()\n}\n\n(function (global) {\n  // Check if WordCloud can run on this browser\n  var isSupported = (function isSupported () {\n    var canvas = document.createElement('canvas')\n    if (!canvas || !canvas.getContext) {\n      return false\n    }\n\n    var ctx = canvas.getContext('2d')\n    if (!ctx) {\n      return false\n    }\n    if (!ctx.getImageData) {\n      return false\n    }\n    if (!ctx.fillText) {\n      return false\n    }\n\n    if (!Array.prototype.some) {\n      return false\n    }\n    if (!Array.prototype.push) {\n      return false\n    }\n\n    return true\n  }())\n\n  // Find out if the browser impose minium font size by\n  // drawing small texts on a canvas and measure it's width.\n  var minFontSize = (function getMinFontSize () {\n    if (!isSupported) {\n      return\n    }\n\n    var ctx = document.createElement('canvas').getContext('2d')\n\n    // start from 20\n    var size = 20\n\n    // two sizes to measure\n    var hanWidth, mWidth\n\n    while (size) {\n      ctx.font = size.toString(10) + 'px sans-serif'\n      if ((ctx.measureText('\\uFF37').width === hanWidth) &&\n          (ctx.measureText('m').width) === mWidth) {\n        return (size + 1)\n      }\n\n      hanWidth = ctx.measureText('\\uFF37').width\n      mWidth = ctx.measureText('m').width\n\n      size--\n    }\n\n    return 0\n  })()\n\n  var getItemExtraData = function (item) {\n    if (Array.isArray(item)) {\n      var itemCopy = item.slice()\n      // remove data we already have (word and weight)\n      itemCopy.splice(0, 2)\n      return itemCopy\n    } else {\n      return []\n    }\n  }\n\n  // Based on http://jsfromhell.com/array/shuffle\n  var shuffleArray = function shuffleArray (arr) {\n    for (var j, x, i = arr.length; i;) {\n      j = Math.floor(Math.random() * i)\n      x = arr[--i]\n      arr[i] = arr[j]\n      arr[j] = x\n    }\n    return arr\n  }\n\n  var timer = {};\n  var WordCloud = function WordCloud (elements, options) {\n    if (!isSupported) {\n      return\n    }\n\n    var timerId = Math.floor(Math.random() * Date.now())\n\n    if (!Array.isArray(elements)) {\n      elements = [elements]\n    }\n\n    elements.forEach(function (el, i) {\n      if (typeof el === 'string') {\n        elements[i] = document.getElementById(el)\n        if (!elements[i]) {\n          throw new Error('The element id specified is not found.')\n        }\n      } else if (!el.tagName && !el.appendChild) {\n        throw new Error('You must pass valid HTML elements, or ID of the element.')\n      }\n    })\n\n    /* Default values to be overwritten by options object */\n    var settings = {\n      list: [],\n      fontFamily: '\"Trebuchet MS\", \"Heiti TC\", \"微軟正黑體\", ' +\n                  '\"Arial Unicode MS\", \"Droid Fallback Sans\", sans-serif',\n      fontWeight: 'normal',\n      color: 'random-dark',\n      minSize: 0, // 0 to disable\n      weightFactor: 1,\n      clearCanvas: true,\n      backgroundColor: '#fff', // opaque white = rgba(255, 255, 255, 1)\n\n      gridSize: 8,\n      drawOutOfBound: false,\n      shrinkToFit: false,\n      origin: null,\n\n      drawMask: false,\n      maskColor: 'rgba(255,0,0,0.3)',\n      maskGapWidth: 0.3,\n\n      wait: 0,\n      abortThreshold: 0, // disabled\n      abort: function noop () {},\n\n      minRotation: -Math.PI / 2,\n      maxRotation: Math.PI / 2,\n      rotationSteps: 0,\n\n      shuffle: true,\n      rotateRatio: 0.1,\n\n      shape: 'circle',\n      ellipticity: 0.65,\n\n      classes: null,\n\n      hover: null,\n      click: null\n    }\n\n    if (options) {\n      for (var key in options) {\n        if (key in settings) {\n          settings[key] = options[key]\n        }\n      }\n    }\n\n    /* Convert weightFactor into a function */\n    if (typeof settings.weightFactor !== 'function') {\n      var factor = settings.weightFactor\n      settings.weightFactor = function weightFactor (pt) {\n        return pt * factor // in px\n      }\n    }\n\n    /* Convert shape into a function */\n    if (typeof settings.shape !== 'function') {\n      switch (settings.shape) {\n        case 'circle':\n        /* falls through */\n        default:\n          // 'circle' is the default and a shortcut in the code loop.\n          settings.shape = 'circle'\n          break\n\n        case 'cardioid':\n          settings.shape = function shapeCardioid (theta) {\n            return 1 - Math.sin(theta)\n          }\n          break\n\n          /*\n          To work out an X-gon, one has to calculate \"m\",\n          where 1/(cos(2*PI/X)+m*sin(2*PI/X)) = 1/(cos(0)+m*sin(0))\n          http://www.wolframalpha.com/input/?i=1%2F%28cos%282*PI%2FX%29%2Bm*sin%28\n          2*PI%2FX%29%29+%3D+1%2F%28cos%280%29%2Bm*sin%280%29%29\n          Copy the solution into polar equation r = 1/(cos(t') + m*sin(t'))\n          where t' equals to mod(t, 2PI/X)\n         */\n\n        case 'diamond':\n          // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\n          // %28t%2C+PI%2F2%29%29%2Bsin%28mod+%28t%2C+PI%2F2%29%29%29%2C+t+%3D\n          // +0+..+2*PI\n          settings.shape = function shapeSquare (theta) {\n            var thetaPrime = theta % (2 * Math.PI / 4)\n            return 1 / (Math.cos(thetaPrime) + Math.sin(thetaPrime))\n          }\n          break\n\n        case 'square':\n          // http://www.wolframalpha.com/input/?i=plot+r+%3D+min(1%2Fabs(cos(t\n          // )),1%2Fabs(sin(t)))),+t+%3D+0+..+2*PI\n          settings.shape = function shapeSquare (theta) {\n            return Math.min(\n              1 / Math.abs(Math.cos(theta)),\n              1 / Math.abs(Math.sin(theta))\n            )\n          }\n          break\n\n        case 'triangle-forward':\n          // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\n          // %28t%2C+2*PI%2F3%29%29%2Bsqrt%283%29sin%28mod+%28t%2C+2*PI%2F3%29\n          // %29%29%2C+t+%3D+0+..+2*PI\n          settings.shape = function shapeTriangle (theta) {\n            var thetaPrime = theta % (2 * Math.PI / 3)\n            return 1 / (Math.cos(thetaPrime) +\n                        Math.sqrt(3) * Math.sin(thetaPrime))\n          }\n          break\n\n        case 'triangle':\n        case 'triangle-upright':\n          settings.shape = function shapeTriangle (theta) {\n            var thetaPrime = (theta + Math.PI * 3 / 2) % (2 * Math.PI / 3)\n            return 1 / (Math.cos(thetaPrime) +\n                        Math.sqrt(3) * Math.sin(thetaPrime))\n          }\n          break\n\n        case 'pentagon':\n          settings.shape = function shapePentagon (theta) {\n            var thetaPrime = (theta + 0.955) % (2 * Math.PI / 5)\n            return 1 / (Math.cos(thetaPrime) +\n                        0.726543 * Math.sin(thetaPrime))\n          }\n          break\n\n        case 'star':\n          settings.shape = function shapeStar (theta) {\n            var thetaPrime = (theta + 0.955) % (2 * Math.PI / 10)\n            if ((theta + 0.955) % (2 * Math.PI / 5) - (2 * Math.PI / 10) >= 0) {\n              return 1 / (Math.cos((2 * Math.PI / 10) - thetaPrime) +\n                          3.07768 * Math.sin((2 * Math.PI / 10) - thetaPrime))\n            } else {\n              return 1 / (Math.cos(thetaPrime) +\n                          3.07768 * Math.sin(thetaPrime))\n            }\n          }\n          break\n      }\n    }\n\n    /* Make sure gridSize is a whole number and is not smaller than 4px */\n    settings.gridSize = Math.max(Math.floor(settings.gridSize), 4)\n\n    /* shorthand */\n    var g = settings.gridSize\n    var maskRectWidth = g - settings.maskGapWidth\n\n    /* normalize rotation settings */\n    var rotationRange = Math.abs(settings.maxRotation - settings.minRotation)\n    var rotationSteps = Math.abs(Math.floor(settings.rotationSteps))\n    var minRotation = Math.min(settings.maxRotation, settings.minRotation)\n\n    /* information/object available to all functions, set when start() */\n    var grid, // 2d array containing filling information\n      ngx, ngy, // width and height of the grid\n      center, // position of the center of the cloud\n      maxRadius\n\n    /* timestamp for measuring each putWord() action */\n    var escapeTime\n\n    /* function for getting the color of the text */\n    var getTextColor\n    function randomHslColor (min, max) {\n      return 'hsl(' +\n        (Math.random() * 360).toFixed() + ',' +\n        (Math.random() * 30 + 70).toFixed() + '%,' +\n        (Math.random() * (max - min) + min).toFixed() + '%)'\n    }\n    switch (settings.color) {\n      case 'random-dark':\n        getTextColor = function getRandomDarkColor () {\n          return randomHslColor(10, 50)\n        }\n        break\n\n      case 'random-light':\n        getTextColor = function getRandomLightColor () {\n          return randomHslColor(50, 90)\n        }\n        break\n\n      default:\n        if (typeof settings.color === 'function') {\n          getTextColor = settings.color\n        }\n        break\n    }\n\n    /* function for getting the font-weight of the text */\n    var getTextFontWeight\n    if (typeof settings.fontWeight === 'function') {\n      getTextFontWeight = settings.fontWeight\n    }\n\n    /* function for getting the classes of the text */\n    var getTextClasses = null\n    if (typeof settings.classes === 'function') {\n      getTextClasses = settings.classes\n    }\n\n    /* Interactive */\n    var interactive = false\n    var infoGrid = []\n    var hovered\n\n    var getInfoGridFromMouseTouchEvent =\n    function getInfoGridFromMouseTouchEvent (evt) {\n      var canvas = evt.currentTarget\n      var rect = canvas.getBoundingClientRect()\n      var clientX\n      var clientY\n      /** Detect if touches are available */\n      if (evt.touches) {\n        clientX = evt.touches[0].clientX\n        clientY = evt.touches[0].clientY\n      } else {\n        clientX = evt.clientX\n        clientY = evt.clientY\n      }\n      var eventX = clientX - rect.left\n      var eventY = clientY - rect.top\n\n      var x = Math.floor(eventX * ((canvas.width / rect.width) || 1) / g)\n      var y = Math.floor(eventY * ((canvas.height / rect.height) || 1) / g)\n\n      return infoGrid[x][y]\n    }\n\n    var wordcloudhover = function wordcloudhover (evt) {\n      var info = getInfoGridFromMouseTouchEvent(evt)\n\n      if (hovered === info) {\n        return\n      }\n\n      hovered = info\n      if (!info) {\n        settings.hover(undefined, undefined, evt)\n\n        return\n      }\n\n      settings.hover(info.item, info.dimension, evt)\n    }\n\n    var wordcloudclick = function wordcloudclick (evt) {\n      var info = getInfoGridFromMouseTouchEvent(evt)\n      if (!info) {\n        return\n      }\n\n      settings.click(info.item, info.dimension, evt)\n      evt.preventDefault()\n    }\n\n    /* Get points on the grid for a given radius away from the center */\n    var pointsAtRadius = []\n    var getPointsAtRadius = function getPointsAtRadius (radius) {\n      if (pointsAtRadius[radius]) {\n        return pointsAtRadius[radius]\n      }\n\n      // Look for these number of points on each radius\n      var T = radius * 8\n\n      // Getting all the points at this radius\n      var t = T\n      var points = []\n\n      if (radius === 0) {\n        points.push([center[0], center[1], 0])\n      }\n\n      while (t--) {\n        // distort the radius to put the cloud in shape\n        var rx = 1\n        if (settings.shape !== 'circle') {\n          rx = settings.shape(t / T * 2 * Math.PI) // 0 to 1\n        }\n\n        // Push [x, y, t] t is used solely for getTextColor()\n        points.push([\n          center[0] + radius * rx * Math.cos(-t / T * 2 * Math.PI),\n          center[1] + radius * rx * Math.sin(-t / T * 2 * Math.PI) *\n            settings.ellipticity,\n          t / T * 2 * Math.PI])\n      }\n\n      pointsAtRadius[radius] = points\n      return points\n    }\n\n    /* Return true if we had spent too much time */\n    var exceedTime = function exceedTime () {\n      return ((settings.abortThreshold > 0) &&\n        ((new Date()).getTime() - escapeTime > settings.abortThreshold))\n    }\n\n    /* Get the deg of rotation according to settings, and luck. */\n    var getRotateDeg = function getRotateDeg () {\n      if (settings.rotateRatio === 0) {\n        return 0\n      }\n\n      if (Math.random() > settings.rotateRatio) {\n        return 0\n      }\n\n      if (rotationRange === 0) {\n        return minRotation\n      }\n\n      if (rotationSteps > 0) {\n        // Min rotation + zero or more steps * span of one step\n        return minRotation +\n          Math.floor(Math.random() * rotationSteps) *\n          rotationRange / (rotationSteps - 1)\n      } else {\n        return minRotation + Math.random() * rotationRange\n      }\n    }\n\n    var getTextInfo = function getTextInfo (word, weight, rotateDeg, extraDataArray) {\n      // calculate the acutal font size\n      // fontSize === 0 means weightFactor function wants the text skipped,\n      // and size < minSize means we cannot draw the text.\n      var debug = false\n      var fontSize = settings.weightFactor(weight)\n      if (fontSize <= settings.minSize) {\n        return false\n      }\n\n      // Scale factor here is to make sure fillText is not limited by\n      // the minium font size set by browser.\n      // It will always be 1 or 2n.\n      var mu = 1\n      if (fontSize < minFontSize) {\n        mu = (function calculateScaleFactor () {\n          var mu = 2\n          while (mu * fontSize < minFontSize) {\n            mu += 2\n          }\n          return mu\n        })()\n      }\n\n      // Get fontWeight that will be used to set fctx.font\n      var fontWeight\n      if (getTextFontWeight) {\n        fontWeight = getTextFontWeight(word, weight, fontSize, extraDataArray)\n      } else {\n        fontWeight = settings.fontWeight\n      }\n\n      var fcanvas = document.createElement('canvas')\n      var fctx = fcanvas.getContext('2d', { willReadFrequently: true })\n\n      fctx.font = fontWeight + ' ' +\n        (fontSize * mu).toString(10) + 'px ' + settings.fontFamily\n\n      // Estimate the dimension of the text with measureText().\n      var fw = fctx.measureText(word).width / mu\n      var fh = Math.max(fontSize * mu,\n        fctx.measureText('m').width,\n        fctx.measureText('\\uFF37').width\n      ) / mu\n\n      // Create a boundary box that is larger than our estimates,\n      // so text don't get cut of (it sill might)\n      var boxWidth = fw + fh * 2\n      var boxHeight = fh * 3\n      var fgw = Math.ceil(boxWidth / g)\n      var fgh = Math.ceil(boxHeight / g)\n      boxWidth = fgw * g\n      boxHeight = fgh * g\n\n      // Calculate the proper offsets to make the text centered at\n      // the preferred position.\n\n      // This is simply half of the width.\n      var fillTextOffsetX = -fw / 2\n      // Instead of moving the box to the exact middle of the preferred\n      // position, for Y-offset we move 0.4 instead, so Latin alphabets look\n      // vertical centered.\n      var fillTextOffsetY = -fh * 0.4\n\n      // Calculate the actual dimension of the canvas, considering the rotation.\n      var cgh = Math.ceil((boxWidth * Math.abs(Math.sin(rotateDeg)) +\n                           boxHeight * Math.abs(Math.cos(rotateDeg))) / g)\n      var cgw = Math.ceil((boxWidth * Math.abs(Math.cos(rotateDeg)) +\n                           boxHeight * Math.abs(Math.sin(rotateDeg))) / g)\n      var width = cgw * g\n      var height = cgh * g\n\n      fcanvas.setAttribute('width', width)\n      fcanvas.setAttribute('height', height)\n\n      if (debug) {\n        // Attach fcanvas to the DOM\n        document.body.appendChild(fcanvas)\n        // Save it's state so that we could restore and draw the grid correctly.\n        fctx.save()\n      }\n\n      // Scale the canvas with |mu|.\n      fctx.scale(1 / mu, 1 / mu)\n      fctx.translate(width * mu / 2, height * mu / 2)\n      fctx.rotate(-rotateDeg)\n\n      // Once the width/height is set, ctx info will be reset.\n      // Set it again here.\n      fctx.font = fontWeight + ' ' +\n        (fontSize * mu).toString(10) + 'px ' + settings.fontFamily\n\n      // Fill the text into the fcanvas.\n      // XXX: We cannot because textBaseline = 'top' here because\n      // Firefox and Chrome uses different default line-height for canvas.\n      // Please read https://bugzil.la/737852#c6.\n      // Here, we use textBaseline = 'middle' and draw the text at exactly\n      // 0.5 * fontSize lower.\n      fctx.fillStyle = '#000'\n      fctx.textBaseline = 'middle'\n      fctx.fillText(\n        word, fillTextOffsetX * mu,\n        (fillTextOffsetY + fontSize * 0.5) * mu\n      )\n\n      // Get the pixels of the text\n      var imageData = fctx.getImageData(0, 0, width, height).data\n\n      if (exceedTime()) {\n        return false\n      }\n\n      if (debug) {\n        // Draw the box of the original estimation\n        fctx.strokeRect(\n          fillTextOffsetX * mu,\n          fillTextOffsetY, fw * mu, fh * mu\n        )\n        fctx.restore()\n      }\n\n      // Read the pixels and save the information to the occupied array\n      var occupied = []\n      var gx = cgw\n      var gy, x, y\n      var bounds = [cgh / 2, cgw / 2, cgh / 2, cgw / 2]\n      while (gx--) {\n        gy = cgh\n        while (gy--) {\n          y = g\n          /* eslint no-labels: [\"error\", { \"allowLoop\": true }] */\n          singleGridLoop: while (y--) {\n            x = g\n            while (x--) {\n              if (imageData[((gy * g + y) * width +\n                (gx * g + x)) * 4 + 3]) {\n                occupied.push([gx, gy])\n\n                if (gx < bounds[3]) {\n                  bounds[3] = gx\n                }\n                if (gx > bounds[1]) {\n                  bounds[1] = gx\n                }\n                if (gy < bounds[0]) {\n                  bounds[0] = gy\n                }\n                if (gy > bounds[2]) {\n                  bounds[2] = gy\n                }\n\n                if (debug) {\n                  fctx.fillStyle = 'rgba(255, 0, 0, 0.5)'\n                  fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5)\n                }\n                break singleGridLoop\n              }\n            }\n          }\n          if (debug) {\n            fctx.fillStyle = 'rgba(0, 0, 255, 0.5)'\n            fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5)\n          }\n        }\n      }\n\n      if (debug) {\n        fctx.fillStyle = 'rgba(0, 255, 0, 0.5)'\n        fctx.fillRect(\n          bounds[3] * g,\n          bounds[0] * g,\n          (bounds[1] - bounds[3] + 1) * g,\n          (bounds[2] - bounds[0] + 1) * g\n        )\n      }\n\n      // Return information needed to create the text on the real canvas\n      return {\n        mu: mu,\n        occupied: occupied,\n        bounds: bounds,\n        gw: cgw,\n        gh: cgh,\n        fillTextOffsetX: fillTextOffsetX,\n        fillTextOffsetY: fillTextOffsetY,\n        fillTextWidth: fw,\n        fillTextHeight: fh,\n        fontSize: fontSize\n      }\n    }\n\n    /* Determine if there is room available in the given dimension */\n    var canFitText = function canFitText (gx, gy, gw, gh, occupied) {\n      // Go through the occupied points,\n      // return false if the space is not available.\n      var i = occupied.length\n      while (i--) {\n        var px = gx + occupied[i][0]\n        var py = gy + occupied[i][1]\n\n        if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n          if (!settings.drawOutOfBound) {\n            return false\n          }\n          continue\n        }\n\n        if (!grid[px][py]) {\n          return false\n        }\n      }\n      return true\n    }\n\n    /* Actually draw the text on the grid */\n    var drawText = function drawText (gx, gy, info, word, weight, distance, theta, rotateDeg, attributes, extraDataArray) {\n      var fontSize = info.fontSize\n      var color\n      if (getTextColor) {\n        color = getTextColor(word, weight, fontSize, distance, theta, extraDataArray)\n      } else {\n        color = settings.color\n      }\n\n      // get fontWeight that will be used to set ctx.font and font style rule\n      var fontWeight\n      if (getTextFontWeight) {\n        fontWeight = getTextFontWeight(word, weight, fontSize, extraDataArray)\n      } else {\n        fontWeight = settings.fontWeight\n      }\n\n      var classes\n      if (getTextClasses) {\n        classes = getTextClasses(word, weight, fontSize, extraDataArray)\n      } else {\n        classes = settings.classes\n      }\n\n      elements.forEach(function (el) {\n        if (el.getContext) {\n          var ctx = el.getContext('2d')\n          var mu = info.mu\n\n          // Save the current state before messing it\n          ctx.save()\n          ctx.scale(1 / mu, 1 / mu)\n\n          ctx.font = fontWeight + ' ' +\n                     (fontSize * mu).toString(10) + 'px ' + settings.fontFamily\n          ctx.fillStyle = color\n\n          // Translate the canvas position to the origin coordinate of where\n          // the text should be put.\n          ctx.translate(\n            (gx + info.gw / 2) * g * mu,\n            (gy + info.gh / 2) * g * mu\n          )\n\n          if (rotateDeg !== 0) {\n            ctx.rotate(-rotateDeg)\n          }\n\n          // Finally, fill the text.\n\n          // XXX: We cannot because textBaseline = 'top' here because\n          // Firefox and Chrome uses different default line-height for canvas.\n          // Please read https://bugzil.la/737852#c6.\n          // Here, we use textBaseline = 'middle' and draw the text at exactly\n          // 0.5 * fontSize lower.\n          ctx.textBaseline = 'middle'\n          ctx.fillText(\n            word, info.fillTextOffsetX * mu,\n            (info.fillTextOffsetY + fontSize * 0.5) * mu\n          )\n\n          // The below box is always matches how <span>s are positioned\n          /* ctx.strokeRect(info.fillTextOffsetX, info.fillTextOffsetY,\n            info.fillTextWidth, info.fillTextHeight) */\n\n          // Restore the state.\n          ctx.restore()\n        } else {\n          // drawText on DIV element\n          var span = document.createElement('span')\n          var transformRule = ''\n          transformRule = 'rotate(' + (-rotateDeg / Math.PI * 180) + 'deg) '\n          if (info.mu !== 1) {\n            transformRule +=\n              'translateX(-' + (info.fillTextWidth / 4) + 'px) ' +\n              'scale(' + (1 / info.mu) + ')'\n          }\n          var styleRules = {\n            position: 'absolute',\n            display: 'block',\n            font: fontWeight + ' ' +\n              (fontSize * info.mu) + 'px ' + settings.fontFamily,\n            left: ((gx + info.gw / 2) * g + info.fillTextOffsetX) + 'px',\n            top: ((gy + info.gh / 2) * g + info.fillTextOffsetY) + 'px',\n            width: info.fillTextWidth + 'px',\n            height: info.fillTextHeight + 'px',\n            lineHeight: fontSize + 'px',\n            whiteSpace: 'nowrap',\n            transform: transformRule,\n            webkitTransform: transformRule,\n            msTransform: transformRule,\n            transformOrigin: '50% 40%',\n            webkitTransformOrigin: '50% 40%',\n            msTransformOrigin: '50% 40%'\n          }\n          if (color) {\n            styleRules.color = color\n          }\n          span.textContent = word\n          for (var cssProp in styleRules) {\n            span.style[cssProp] = styleRules[cssProp]\n          }\n          if (attributes) {\n            for (var attribute in attributes) {\n              span.setAttribute(attribute, attributes[attribute])\n            }\n          }\n          if (classes) {\n            span.className += classes\n          }\n          el.appendChild(span)\n        }\n      })\n    }\n\n    /* Help function to updateGrid */\n    var fillGridAt = function fillGridAt (x, y, drawMask, dimension, item) {\n      if (x >= ngx || y >= ngy || x < 0 || y < 0) {\n        return\n      }\n\n      grid[x][y] = false\n\n      if (drawMask) {\n        var ctx = elements[0].getContext('2d')\n        ctx.fillRect(x * g, y * g, maskRectWidth, maskRectWidth)\n      }\n\n      if (interactive) {\n        infoGrid[x][y] = { item: item, dimension: dimension }\n      }\n    }\n\n    /* Update the filling information of the given space with occupied points.\n       Draw the mask on the canvas if necessary. */\n    var updateGrid = function updateGrid (gx, gy, gw, gh, info, item) {\n      var occupied = info.occupied\n      var drawMask = settings.drawMask\n      var ctx\n      if (drawMask) {\n        ctx = elements[0].getContext('2d')\n        ctx.save()\n        ctx.fillStyle = settings.maskColor\n      }\n\n      var dimension\n      if (interactive) {\n        var bounds = info.bounds\n        dimension = {\n          x: (gx + bounds[3]) * g,\n          y: (gy + bounds[0]) * g,\n          w: (bounds[1] - bounds[3] + 1) * g,\n          h: (bounds[2] - bounds[0] + 1) * g\n        }\n      }\n\n      var i = occupied.length\n      while (i--) {\n        var px = gx + occupied[i][0]\n        var py = gy + occupied[i][1]\n\n        if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n          continue\n        }\n\n        fillGridAt(px, py, drawMask, dimension, item)\n      }\n\n      if (drawMask) {\n        ctx.restore()\n      }\n    }\n\n    /* putWord() processes each item on the list,\n       calculate it's size and determine it's position, and actually\n       put it on the canvas. */\n    var putWord = function putWord (item) {\n      var word, weight, attributes\n      if (Array.isArray(item)) {\n        word = item[0]\n        weight = item[1]\n      } else {\n        word = item.word\n        weight = item.weight\n        attributes = item.attributes\n      }\n      var rotateDeg = getRotateDeg()\n\n      var extraDataArray = getItemExtraData(item)\n\n      // get info needed to put the text onto the canvas\n      var info = getTextInfo(word, weight, rotateDeg, extraDataArray)\n\n      // not getting the info means we shouldn't be drawing this one.\n      if (!info) {\n        return false\n      }\n\n      if (exceedTime()) {\n        return false\n      }\n\n      // If drawOutOfBound is set to false,\n      // skip the loop if we have already know the bounding box of\n      // word is larger than the canvas.\n      if (!settings.drawOutOfBound && !settings.shrinkToFit) {\n        var bounds = info.bounds;\n        if ((bounds[1] - bounds[3] + 1) > ngx ||\n          (bounds[2] - bounds[0] + 1) > ngy) {\n          return false\n        }\n      }\n\n      // Determine the position to put the text by\n      // start looking for the nearest points\n      var r = maxRadius + 1\n\n      var tryToPutWordAtPoint = function (gxy) {\n        var gx = Math.floor(gxy[0] - info.gw / 2)\n        var gy = Math.floor(gxy[1] - info.gh / 2)\n        var gw = info.gw\n        var gh = info.gh\n\n        // If we cannot fit the text at this position, return false\n        // and go to the next position.\n        if (!canFitText(gx, gy, gw, gh, info.occupied)) {\n          return false\n        }\n\n        // Actually put the text on the canvas\n        drawText(gx, gy, info, word, weight,\n          (maxRadius - r), gxy[2], rotateDeg, attributes, extraDataArray)\n\n        // Mark the spaces on the grid as filled\n        updateGrid(gx, gy, gw, gh, info, item)\n\n        // Return true so some() will stop and also return true.\n        return true\n      }\n\n      while (r--) {\n        var points = getPointsAtRadius(maxRadius - r)\n\n        if (settings.shuffle) {\n          points = [].concat(points)\n          shuffleArray(points)\n        }\n\n        // Try to fit the words by looking at each point.\n        // array.some() will stop and return true\n        // when putWordAtPoint() returns true.\n        // If all the points returns false, array.some() returns false.\n        var drawn = points.some(tryToPutWordAtPoint)\n\n        if (drawn) {\n          // leave putWord() and return true\n          return true\n        }\n      }\n      if (settings.shrinkToFit) {\n        if (Array.isArray(item)) {\n          item[1] = item[1] * 3 / 4\n        } else {\n          item.weight = item.weight * 3 / 4\n        }\n        return putWord(item)\n      }\n      // we tried all distances but text won't fit, return false\n      return false\n    }\n\n    /* Send DOM event to all elements. Will stop sending event and return\n       if the previous one is canceled (for cancelable events). */\n    var sendEvent = function sendEvent (type, cancelable, details) {\n      if (cancelable) {\n        return !elements.some(function (el) {\n          var event = new CustomEvent(type, {\n            detail: details || {}\n          })\n          return !el.dispatchEvent(event)\n        }, this)\n      } else {\n        elements.forEach(function (el) {\n          var event = new CustomEvent(type, {\n            detail: details || {}\n          })\n          el.dispatchEvent(event)\n        }, this)\n      }\n    }\n\n    /* Start drawing on a canvas */\n    var start = function start () {\n      // For dimensions, clearCanvas etc.,\n      // we only care about the first element.\n      var canvas = elements[0]\n\n      if (canvas.getContext) {\n        ngx = Math.ceil(canvas.width / g)\n        ngy = Math.ceil(canvas.height / g)\n      } else {\n        var rect = canvas.getBoundingClientRect()\n        ngx = Math.ceil(rect.width / g)\n        ngy = Math.ceil(rect.height / g)\n      }\n\n      // Sending a wordcloudstart event which cause the previous loop to stop.\n      // Do nothing if the event is canceled.\n      if (!sendEvent('wordcloudstart', true)) {\n        return\n      }\n\n      // Determine the center of the word cloud\n      center = (settings.origin)\n        ? [settings.origin[0] / g, settings.origin[1] / g]\n        : [ngx / 2, ngy / 2]\n\n      // Maxium radius to look for space\n      maxRadius = Math.floor(Math.sqrt(ngx * ngx + ngy * ngy))\n\n      /* Clear the canvas only if the clearCanvas is set,\n         if not, update the grid to the current canvas state */\n      grid = []\n\n      var gx, gy, i\n      if (!canvas.getContext || settings.clearCanvas) {\n        elements.forEach(function (el) {\n          if (el.getContext) {\n            var ctx = el.getContext('2d')\n            ctx.fillStyle = settings.backgroundColor\n            ctx.clearRect(0, 0, ngx * (g + 1), ngy * (g + 1))\n            ctx.fillRect(0, 0, ngx * (g + 1), ngy * (g + 1))\n          } else {\n            el.textContent = ''\n            el.style.backgroundColor = settings.backgroundColor\n            el.style.position = 'relative'\n          }\n        })\n\n        /* fill the grid with empty state */\n        gx = ngx\n        while (gx--) {\n          grid[gx] = []\n          gy = ngy\n          while (gy--) {\n            grid[gx][gy] = true\n          }\n        }\n      } else {\n        /* Determine bgPixel by creating\n           another canvas and fill the specified background color. */\n        var bctx = document.createElement('canvas').getContext('2d')\n\n        bctx.fillStyle = settings.backgroundColor\n        bctx.fillRect(0, 0, 1, 1)\n        var bgPixel = bctx.getImageData(0, 0, 1, 1).data\n\n        /* Read back the pixels of the canvas we got to tell which part of the\n           canvas is empty.\n           (no clearCanvas only works with a canvas, not divs) */\n        var imageData =\n          canvas.getContext('2d').getImageData(0, 0, ngx * g, ngy * g).data\n\n        gx = ngx\n        var x, y\n        while (gx--) {\n          grid[gx] = []\n          gy = ngy\n          while (gy--) {\n            y = g\n            /* eslint no-labels: [\"error\", { \"allowLoop\": true }] */\n            singleGridLoop: while (y--) {\n              x = g\n              while (x--) {\n                i = 4\n                while (i--) {\n                  if (imageData[((gy * g + y) * ngx * g +\n                                 (gx * g + x)) * 4 + i] !== bgPixel[i]) {\n                    grid[gx][gy] = false\n                    break singleGridLoop\n                  }\n                }\n              }\n            }\n            if (grid[gx][gy] !== false) {\n              grid[gx][gy] = true\n            }\n          }\n        }\n\n        imageData = bctx = bgPixel = undefined\n      }\n\n      // fill the infoGrid with empty state if we need it\n      if (settings.hover || settings.click) {\n        interactive = true\n\n        /* fill the grid with empty state */\n        gx = ngx + 1\n        while (gx--) {\n          infoGrid[gx] = []\n        }\n\n        if (settings.hover) {\n          canvas.addEventListener('mousemove', wordcloudhover)\n        }\n\n        if (settings.click) {\n          canvas.addEventListener('click', wordcloudclick)\n          canvas.style.webkitTapHighlightColor = 'rgba(0, 0, 0, 0)'\n        }\n\n        canvas.addEventListener('wordcloudstart', function stopInteraction () {\n          canvas.removeEventListener('wordcloudstart', stopInteraction)\n          canvas.removeEventListener('mousemove', wordcloudhover)\n          canvas.removeEventListener('click', wordcloudclick)\n          hovered = undefined\n        })\n      }\n\n      i = 0\n      var loopingFunction, stoppingFunction\n      if (settings.wait !== 0) {\n        loopingFunction = window.setTimeout\n        stoppingFunction = window.clearTimeout\n      } else {\n        loopingFunction = window.setImmediate\n        stoppingFunction = window.clearImmediate\n      }\n\n      var addEventListener = function addEventListener (type, listener) {\n        elements.forEach(function (el) {\n          el.addEventListener(type, listener)\n        }, this)\n      }\n\n      var removeEventListener = function removeEventListener (type, listener) {\n        elements.forEach(function (el) {\n          el.removeEventListener(type, listener)\n        }, this)\n      }\n\n      var anotherWordCloudStart = function anotherWordCloudStart () {\n        removeEventListener('wordcloudstart', anotherWordCloudStart)\n        stoppingFunction(timer[timerId])\n      }\n\n      addEventListener('wordcloudstart', anotherWordCloudStart)\n      timer[timerId] = loopingFunction(function loop () {\n        if (i >= settings.list.length) {\n          stoppingFunction(timer[timerId])\n          sendEvent('wordcloudstop', false)\n          removeEventListener('wordcloudstart', anotherWordCloudStart)\n          delete timer[timerId];\n          return\n        }\n        escapeTime = (new Date()).getTime()\n        var drawn = putWord(settings.list[i])\n        var canceled = !sendEvent('wordclouddrawn', true, {\n          item: settings.list[i],\n          drawn: drawn\n        })\n        if (exceedTime() || canceled) {\n          stoppingFunction(timer[timerId])\n          settings.abort()\n          sendEvent('wordcloudabort', false)\n          sendEvent('wordcloudstop', false)\n          removeEventListener('wordcloudstart', anotherWordCloudStart)\n          delete timer[timerId]\n          return\n        }\n        i++\n        timer[timerId] = loopingFunction(loop, settings.wait)\n      }, settings.wait)\n    }\n\n    // All set, start the drawing\n    start()\n  }\n\n  WordCloud.isSupported = isSupported\n  WordCloud.minFontSize = minFontSize\n  WordCloud.stop = function stop () {\n    if (timer) {\n      for (var timerId in timer) {\n        window.clearImmediate(timer[timerId])\n      }\n    }\n  }\n\n  // Expose the library as an AMD module\n  if (typeof define === 'function' && define.amd) { // eslint-disable-line no-undef\n    global.WordCloud = WordCloud\n    define('wordcloud', [], function () { return WordCloud }) // eslint-disable-line no-undef\n  } else if (typeof module !== 'undefined' && module.exports) { // eslint-disable-line no-undef\n    module.exports = WordCloud // eslint-disable-line no-undef\n  } else {\n    global.WordCloud = WordCloud\n  }\n})(this) // jshint ignore:line\n"],"names":["global","isSupported","minFontSize","shuffleArray","timer","WordCloud","window","setImmediate","msSetImmediate","webkitSetImmediate","mozSetImmediate","oSetImmediate","postMessage","addEventListener","callbacks","undefined","message","evt","data","substr","length","stopImmediatePropagation","id","parseInt","clearImmediate","callback","push","toString","fn","setTimeout","msClearImmediate","webkitClearImmediate","mozClearImmediate","oClearImmediate","clearTimeout","this","canvas","document","createElement","getContext","ctx","getImageData","fillText","Array","prototype","some","hanWidth","mWidth","size","font","measureText","width","arr","j","x","i","Math","floor","random","elements","options","timerId","Date","now","isArray","forEach","el","getElementById","Error","tagName","appendChild","settings","list","fontFamily","fontWeight","color","minSize","weightFactor","clearCanvas","backgroundColor","gridSize","drawOutOfBound","shrinkToFit","origin","drawMask","maskColor","maskGapWidth","wait","abortThreshold","abort","minRotation","PI","maxRotation","rotationSteps","shuffle","rotateRatio","shape","ellipticity","classes","hover","click","key","factor","pt","theta","sin","thetaPrime","cos","min","abs","sqrt","max","grid","ngx","ngy","center","maxRadius","escapeTime","getTextColor","getTextFontWeight","g","maskRectWidth","rotationRange","randomHslColor","getTextClasses","hovered","interactive","infoGrid","getInfoGridFromMouseTouchEvent","clientX","clientY","currentTarget","rect","getBoundingClientRect","touches","eventX","left","eventY","top","y","height","wordcloudhover","info","item","dimension","wordcloudclick","preventDefault","pointsAtRadius","getPointsAtRadius","radius","T","t","points","rx","exceedTime","getTime","fillGridAt","fillRect","putWord","word","weight","attributes","rotateDeg","extraDataArray","itemCopy","slice","splice","getItemExtraData","fontSize","mu","fcanvas","fctx","willReadFrequently","fw","fh","boxWidth","boxHeight","fgw","ceil","fgh","fillTextOffsetX","fillTextOffsetY","cgh","cgw","setAttribute","scale","translate","rotate","fillStyle","textBaseline","imageData","gy","occupied","gx","bounds","singleGridLoop","gw","gh","fillTextWidth","fillTextHeight","getTextInfo","r","tryToPutWordAtPoint","gxy","px","py","canFitText","distance","save","restore","span","transformRule","styleRules","position","display","lineHeight","whiteSpace","transform","webkitTransform","msTransform","transformOrigin","webkitTransformOrigin","msTransformOrigin","cssProp","textContent","style","attribute","className","drawText","w","h","updateGrid","concat","sendEvent","type","cancelable","details","event","CustomEvent","detail","dispatchEvent","loopingFunction","stoppingFunction","clearRect","bctx","bgPixel","webkitTapHighlightColor","stopInteraction","removeEventListener","listener","anotherWordCloudStart","loop","drawn","canceled","start","toFixed","stop","define","amd","module","exports"],"mappings":"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"}